module Assignment3 where

    import Data.List
    import Control.Monad
    import Lecture5

   {-- Time spent: 1 hour
    --
    -- 
    -- *Assignment3> test 100 prop_minimal 
    -- pass on:
    -- +-------+-------+-------+
    -- |     4 | 9   3 |       |
    -- |     1 |   8   |     2 |
    -- |       |       |       |
    -- +-------+-------+-------+
    -- |       |   9 2 |   6 3 |
    -- |   2   | 6     |       |
    -- | 8     |   5   | 1     |
    -- +-------+-------+-------+
    -- | 7   5 |       |     6 |
    -- | 3   6 |       |   4 7 |
    -- |       |   3   | 8     |
    -- +-------+-------+-------+
    -- 1/100
    -- ...
    -- pass on:
    -- +-------+-------+-------+
    -- |       |     6 |     8 |
    -- | 9 7 4 | 1     |       |
    -- |       |   2   |       |
    -- +-------+-------+-------+
    -- |       |   1   |     9 |
    -- | 1 5   | 7     | 3     |
    -- |       |       | 6   5 |
    -- +-------+-------+-------+
    -- |     5 |       |       |
    -- |     1 | 9   3 |   5   |
    -- | 7     | 8   2 |   9   |
    -- +-------+-------+-------+
    -- 100/100
    -- 100 tests passed
    --}

    -- From Lecture5 main function, without the showing, and returning the node created.
    genRandomProblem :: IO Node
    genRandomProblem = do [r] <- rsolveNs [emptyN]
                          genProblem r

    -- Minimal property, a node should be uniquely solvable by itself, and also by erasing any position
    -- should still be uniquely solvable.   
    prop_minimal node =
            uniqueSol node && not (any uniqueSol (map (eraseN node) (filledPositions (fst node))))

    -- convenience function for testR (Usage: test [n-tests] [property])
    test :: Int -> (Node -> Bool) -> IO ()
    test = testR 0

    -- modified version of lecture 2
    testR :: Int -> Int -> (Node -> Bool) -> IO ()
    testR k n f = if k == n then putStr (show n ++ " tests passed\n")
                    else do
                      node <- genRandomProblem
                      if f node then
                        do putStr "pass on:\n"
                           showNode node
                           putStr (show (k+1) ++ "/" ++ show n ++ "\n")
                           testR (k+1) n f
                      else 
                        do putStr "failed test on:\n"
                           showNode node
                           error ("Failed on test " ++ show (k+1) ++ "/" ++ show n)

    -- generated by using minimalize on example1
    minimal :: Grid
    minimal = [[0,3,0,0,0,0,0,0,0],
               [0,0,0,1,0,5,0,0,0],
               [0,9,8,0,0,0,0,6,0],
               [0,0,0,0,6,0,0,0,3],
               [4,0,0,8,0,3,0,0,1],
               [7,0,0,0,2,0,0,0,0],
               [0,6,0,0,0,0,2,8,0],
               [0,0,0,0,1,9,0,0,5],
               [0,0,0,0,8,0,0,7,9]]
